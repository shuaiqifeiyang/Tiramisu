[{"categories":["CSCI-570 Analysis of Algorithm"],"content":"570 复习 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:0:0","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Week1 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:1:0","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Stable Matching Problem 给定n个男生和n个女生，每个男生都有一个对所有女生的排名，每个女生也有一个对所有男生的排名 Perfect matching: 男女一对一 Instability：假设m和w匹配，m’和w’匹配，如果m更喜欢w‘，w’更喜欢m，这个时候称（m，w‘）为instability Matching S is stable if it is perfect there are no instabilities. Gale-Shapley Algorithm: 男生求婚版本：从没有匹配的男生集合中挑选一个男生，从他的列表上排名最高且他没有求过婚的女生开始选，如果这个女生已经和另一个男生匹配了，比较这两个男生在女生心中的优先级，让女生和她更喜欢的男生匹配，淘汰的男生放入没有匹配的男生的集合中 女生求婚版本 结论： 如果一个女生匹配了，那么当她engaged后，她会一直保持engaged 算法会在最大$n^2$次迭代后终止 在$O(1)$的时间复杂度比较两个男生在女生心中的排序，把男生的序号变成index，排名变成value valid partner：能够在一个stable matching中存在pair(m, w)，那么m和w称为互相的valid partner 每一次G-S算法都会得到同样的stable matching，无论男生求婚的顺序如何。在男生求婚的版本中，男生最后都会和他的best valid partner结婚，女生都会和他的worst valid partner结婚 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:1:1","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Week2 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:2:0","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Asymptotic Notation O(g(n)) = {f(n) | there exist positive constant C and $n_0$ such that 0\u003c=f(n)\u003c=Cg(n) for all n\u003e=$n_0$} $\\Omega$(g(n)) = {f(n) | there exist positive constant C and $n_0$ such that 0\u003c=Cg(n)\u003c=f(n) for all n\u003e=$n_0$} $\\Theta$(g(n)) = {f(n) | there exist positive constant $C_1$ and $C_2$ and $n_0$ such that 0\u003c=$C_1$g(n)\u003c=f(n)\u003c=$C_2$g(n) for all n\u003e=$n_0$} 在比较Asymptotic Notation的大小的时候，Exponential \u003e Polynomial \u003e logarithmic 不能通过简单的Asymptotic Notation来比较算法的快慢，要考虑到数据量的大小。 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:2:1","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"BFS \u0026 DFS 在一个图的BFS tree中，如果在在图中两个节点是相连的，那么在BFS Tree中这两个节点在同一层或者相差一层 判断一个图是否是bipartite 如果图中有一个环有奇数个节点，那么这个图不可能是bipartite 先通过运行BFS把BFS Tree中相邻层的节点标记为Red和Blue，然后遍历边，如果有一条边的两个端点是同一个颜色，说明不是bipartite。整个的算法复杂度是$O(m+n)$ 判断一个 有向图是否是Strong Connected： If there is a path from any point to any other point in the graph, 那么这个图就叫有向图 先任选一个点s运行BFS或者DFS，判断是不是所有的其他点都可以到达。再将图中所有的边反转，又从s点运行DFS或者DFS，判断是不是所有的其他点都可以到达 判断在DAG中是否存在一条Path访问所有的节点： 现在O(m+n)的时间复杂度内得到这个 有向图的拓扑排序，然后判断拓扑顺序中相邻两个节点之间是否有边 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:2:2","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Interval Scheduling Problem 给定n个间隔，求出最大的不向冲突的间隔个数 将这些间隔按照结束时间排好序，遍历这些间隔，把不冲突的间隔选入。时间复杂度是$O(nlogn)$ 证明方法：证明每一步都不会比optimal solution差 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:2:3","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Week 3 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:3:0","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Scheduling to Minimize Lateness 给定n个任务，完成每个任务需要一点时间，每个任务都有一个ddl。安排这些任务，minimize the maximum lateness 将这些任务按照ddl大小没有间隔地安排 证明方法： 定义inversion：先安排ddl晚的任务 我们的solution没有inversion 消除inversion不会影响optimality，所有的optimal solution都可以转化为我们的solution ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:3:1","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Priority Queue Full Binary Tree：二叉树全满 Complete Binary Tree：二叉树除了最后一行全满，且最后一行左边全满 Binary Heap各种操作实现 Find Max O(1) insert，先把要插入的元素放在最末尾，然后上滤 O(logn) Delete，把最后一个元素放在要删去的元素的位置，上滤或者下滤把元素放在合适的位置 O(logn) Dcrease-key O(logn) 可以用O(n)的时间复杂度建立堆 合并两个binary heap需要O(N)的时间 用binary heap找一个数组中第k大的值 O(nlogk) binomial heap各种操作的实现 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:3:2","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Amortized Cost Analysis Aggregate Analysis:算出n个操作总过耗费T(n)，那么每个操作的amortized cost是T(n)/n Accounting Method:给一些操作更多change，多出来的change作为credit，credit可以用来弥补之后change比实际少的操作 ![截屏2021-11-30 14.47.24](/Users/shuaiqifeiyang/Library/Application Support/typora-user-images/截屏2021-11-30 14.47.24.png) ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:3:3","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Week4 对于每条边的w都大于等于0的无向图，找出起点到终点的最短路径 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:4:0","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Dijkstra Algorithm 算法过程 Start with a set S of vertices whose final shortest path we already know At each step, find a vertex u$\\in$V-S with shortest distance from s Add u to S and repeat 证明方法: 用induction+contradiction的方法证明每次加到S中的点都找到了最短路径 算法复杂度分析，Dijkstra用了n次ExtractMins和m次DecreaseKeys，对应的时间复杂度 ![截屏2021-11-30 16.44.40](/Users/shuaiqifeiyang/Library/Application Support/typora-user-images/截屏2021-11-30 16.44.40.png) ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:4:1","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Minimum Spinning Tree Spinning Tree是包含图中所有节点的Tree Minimum Spinning Tree是所有edge权重加起来最小的Spinning Tree Assume that all edge costs are distinct. Let C be any cycle in G, and let edge e = (v, w) be the most expensive edge belonging to C. Then e does not belong to any minimum spanning tree of G. Kruskal’s Algorithm 将所有edge按照cost排序，依次把edge加入Spinning Tree中如果加入这个edge后不会成环 Kruskal中用Union-Find数据结构判断两个点是否已经连起来了。 给边排序O(mlogm) 对于每条边，利用Union-Find检查是否成环O(mlogn) 总共的时间复杂度是O(mlogm) Pims’s Algorithm 类似于Dijkstra算法，每次加入集合的不是离起点最近的节点，而是和set相连的距离最近的节点 Reverse-Delete 将所有的edge按照cost排序，从cost大的开始删除图中的边，直到最后的结果是一个树 假设所有边的cost都是不一样的，Let S be any subset of nodes that is neither empty nor equal to all of V, and let edge e=(v, w) be the min cost edge with one end in S and the other end in V-S. Then every MST contains the edge e. ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:4:2","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Clustering 把一个集合U分为k个集合称为k-clustering of U spacing of a k-clustering是minimum distance between any pair of points lying in different clusters Given a set of n objects, find a k-clustering with maximum spacing 先找出来最小生成树，再删除最小生成树的k-1个most expensive edges 证明方法：contradiction，如果有另外一个k-cluster，那么我们现有的一个cluster必然在新的k-cluster里面会被拆开，那么这时的space会变小 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:4:3","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Discussion 反转道路的方向 当有多个起点的时候引入一个新的起点，然后将新的起点指向多个原来的起点 ","date":"2021-11-29","objectID":"/zh-cn/posts/algorithm/570-reviews/:4:4","tags":["Algorithm"],"title":"570 Reviews","uri":"/zh-cn/posts/algorithm/570-reviews/"},{"categories":null,"content":"二分法 2064. Minimized Maximum of Products Distributed to Any Store ","date":"2021-11-07","objectID":"/zh-cn/posts/leetcode-single/2000/2064/:0:0","tags":null,"title":"2064. Minimized Maximum of Products Distributed to Any Store","uri":"/zh-cn/posts/leetcode-single/2000/2064/"},{"categories":null,"content":"题意 给定一个有m个元素的整数数组，将数组中的元素分裂，得到一个有n个元素的数组，新数组的最大元素是maxn，求maxn的最小值 ","date":"2021-11-07","objectID":"/zh-cn/posts/leetcode-single/2000/2064/:1:0","tags":null,"title":"2064. Minimized Maximum of Products Distributed to Any Store","uri":"/zh-cn/posts/leetcode-single/2000/2064/"},{"categories":null,"content":"解法 二分法。 原数组中的每个元素x，需要在分裂后的数组中占据$\\lceil$x/maxn$\\rceil$多个位置。我们用二分法找maxn使分裂后的数组的位置数等于n ","date":"2021-11-07","objectID":"/zh-cn/posts/leetcode-single/2000/2064/:2:0","tags":null,"title":"2064. Minimized Maximum of Products Distributed to Any Store","uri":"/zh-cn/posts/leetcode-single/2000/2064/"},{"categories":null,"content":"代码 class Solution { public: int minimizedMaximum(int n, vector\u003cint\u003e\u0026 quantities) { int left=1, right=100000; while(left\u003cright){ int mid=left+(right-left)/2; int countOfStore=0; for(int q: quantities){ countOfStore+=(q+mid-1)/mid; } if(countOfStore\u003en){ left=mid+1; }else if(countOfStore\u003c=n){ right=mid; } } return left; } }; ","date":"2021-11-07","objectID":"/zh-cn/posts/leetcode-single/2000/2064/:3:0","tags":null,"title":"2064. Minimized Maximum of Products Distributed to Any Store","uri":"/zh-cn/posts/leetcode-single/2000/2064/"},{"categories":null,"content":"887. Super Egg Drop ","date":"2021-11-02","objectID":"/zh-cn/posts/leetcode-single/800/887-super-egg-drop/:0:0","tags":null,"title":"887 Super Egg Drop","uri":"/zh-cn/posts/leetcode-single/800/887-super-egg-drop/"},{"categories":null,"content":"题意 一个房子有n层楼，存在一个楼层f(0\u003c=f\u003c=n)，当从f层楼或者f层楼以下扔鸡蛋，鸡蛋不会摔碎。如果从f层楼之上扔鸡蛋，鸡蛋会摔碎。告诉你有k个鸡蛋并且楼房有n层楼，至少需要扔多少次鸡蛋可以找出楼层f。 ","date":"2021-11-02","objectID":"/zh-cn/posts/leetcode-single/800/887-super-egg-drop/:1:0","tags":null,"title":"887 Super Egg Drop","uri":"/zh-cn/posts/leetcode-single/800/887-super-egg-drop/"},{"categories":null,"content":"算法 动态规划解决。 dp[M][K]表示给K个鸡蛋，扔鸡蛋M次，能够在dp[M][K]层楼中找到f 初始状态：dp[0][k]=0(0\u003c=k\u003c=K)，表示给0个鸡蛋，无论扔多少次都只能找到0层楼中的f 递推关系：dp[m][k]=dp[m-1][k-1]+1+dp[m-1][k]。 这个递推的关系的意思是：最先从dp[m-1][k-1]+1层楼扔鸡蛋，如果鸡蛋碎了，证明需要在dp[m-1][k-1]+1的下面找f，如果鸡蛋没碎，证明需要在dp[m-1][k-1]+1上面找f。下面能够达到的最大的楼层是dp[m-1][k-1]，上面能够达到的最大的楼层是dp[m-1][k]。 ","date":"2021-11-02","objectID":"/zh-cn/posts/leetcode-single/800/887-super-egg-drop/:2:0","tags":null,"title":"887 Super Egg Drop","uri":"/zh-cn/posts/leetcode-single/800/887-super-egg-drop/"},{"categories":null,"content":"代码 class Solution { public: int superEggDrop(int k, int n) { vector\u003cvector\u003cint\u003e\u003e dp(k+1, vector\u003cint\u003e(n+1, 0)); //int maxFloor=0; int dropCnt=0; while(dp[k][dropCnt]\u003cn){ dropCnt++; for(int eggCnt=1;eggCnt\u003c=k;eggCnt++){ dp[eggCnt][dropCnt]=dp[eggCnt-1][dropCnt-1]+1+dp[eggCnt][dropCnt-1]; // maxFloor=max(maxFloor, dp[eggCnt][dropCnt]); } } return dropCnt; } }; ","date":"2021-11-02","objectID":"/zh-cn/posts/leetcode-single/800/887-super-egg-drop/:3:0","tags":null,"title":"887 Super Egg Drop","uri":"/zh-cn/posts/leetcode-single/800/887-super-egg-drop/"},{"categories":["Leetcode frequency"],"content":"复习Leetcode高频题1-20 ","date":"2021-10-26","objectID":"/zh-cn/posts/leetcode-frequency/leetcode-frequency-1-20/:0:0","tags":["Algorithm","Leetcode"],"title":"Leetcode高频题1-20","uri":"/zh-cn/posts/leetcode-frequency/leetcode-frequency-1-20/"},{"categories":null,"content":"我现在在USC上学，对React、GoLang、Computer Graphics有兴趣。 ","date":"2021-10-25","objectID":"/zh-cn/about/:0:0","tags":null,"title":"About","uri":"/zh-cn/about/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"Max Flow问题","date":"2021-10-24","objectID":"/zh-cn/posts/algorithm/max-flow/","tags":["Algorithm"],"title":"最大流","uri":"/zh-cn/posts/algorithm/max-flow/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"这篇文章介绍了Max Flow问题 ","date":"2021-10-24","objectID":"/zh-cn/posts/algorithm/max-flow/:0:0","tags":["Algorithm"],"title":"最大流","uri":"/zh-cn/posts/algorithm/max-flow/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"1. Problem Statement Flow Networks：a directed graph $G=(E, V)$ with the following features: Associated with each edge e is a capacity, which is nonnegative number that we denote $c_e$. There is a single source node $s\\in V$. There is a single sink node $t\\in V$. Assumptions about the flow networks we deal with: No edge enters the source $s$ and no edge leaves the sink $t$. At least one edge incident to each node. All capacities are integers Flow: An s-t flow is a function f that maps each edge e to a nonnegative real number, $f : E \\to \\mathbf{R} ^+$; the value $f(e)$ intuitively represents the amount of flow carried by edge $e$. A flow f must satisfy the following two properties. (Capacity conditions) For each $e\\in E$, we have $0\\leq f(e)\\leq c_e$. (Conservation conditions) For each node $v$ other than $s$ and $t$, we have $$\\sum_{e\\ into\\ v} f(e)=\\sum_{e\\ out\\ of\\ v} f(e)$$ The value of a flow, denoted $v(f)$, is defined to be the amount of flow generated at the source: $$v(f)=\\sum_{e\\ out\\ of\\ s} f(e)$$ The Maximum-Flow Problem: Given a flow network, find a flow of maximum posiible value. ","date":"2021-10-24","objectID":"/zh-cn/posts/algorithm/max-flow/:1:0","tags":["Algorithm"],"title":"最大流","uri":"/zh-cn/posts/algorithm/max-flow/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"2. Present a Solution The Residual Graph: Given a flow network $G$, and a flow $f$ on $G$, we define the residual graph $G_f$ of G with repect to f as follows. The node set of $G_f$ is the same as that of $G$. For each edge $e=(u,v)$ of $G$, if $f(e)\u003cc_e$, it indicages that there are $c_e-f(e)$ “leftover” units of capacity on which we could try pushing flow forward. So we include the edge $e=(u,v)$ in $G_f$, with a capacity of $c_e-f(e)$. We will call edges included this way forward edges. For each edge $e=(u,v)$ of $G$ on which $f(e)\u003e0$, there are $f(e)$ units of flow that we can “undo” if we want to, by pushing flow backward. So we include the edge $e^\\prime = (v, u)$ in $G_f$ , with a capacity of $f(e)$. Note that $e^\\prime$ has the same ends as $e$, but its direction is reversed; we will call edges included this way backward edges. Augmenting Paths in a Residual Graph Assume we have a flow of a network, we want to increase the value of the flow. The method is to find a s-t path $P$ in $G_f$, we define $bottleneck(P,f)$ to be the minimum residual capacity of any edge on $P$. For each edge belong to $P$, if it’s a forward edge, increase $f(e)$ by $bottleneck(P, f)$, if it’s a backward edge, decrease $f(e)$ in $G$ by $bottleneck(P, f)$. Ford-Fulkerson Algorithm Max-Flow Initially $f(e) = 0$ for all $e$ in $G$ While there is an s-t path in the residual graph $G_f$ Let $P$ be a simple s-t path in $G_f$ $f^\\prime$ = augment($f$, $P$) Update $f$ to be $f^\\prime$ Update the residual graph $G_f$ to be $G_f^\\prime$ Endwhile Return $f$ ","date":"2021-10-24","objectID":"/zh-cn/posts/algorithm/max-flow/:2:0","tags":["Algorithm"],"title":"最大流","uri":"/zh-cn/posts/algorithm/max-flow/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"3. Prove Crectness definition: s-t cut: a partition (A, B) of the vertex set V, so that $s\\in A$ and $t\\in B$ the capacity of a cut(A, B): $c(A, B)=\\sum_{e\\ out\\ of\\ A}c_e$ some conclusions: Let $f$ be any s-t flow, and (A, B) any s-t cut. Then $v(f) = f^{out}(A) − f^{in}(A)=f^{in}(B) − f^{out}(B)$. Let f be any s-t flow, and (A, B) any s-t cut. Then $v(f ) \\leq c(A, B)$. important conclusions: If $f$ is an s-t flow such that there is no s-t path in the residual graph $G_f$, then there is an s-t cut $(A^\\ast, B^\\ast)$ in $G$ for which $v(f) = c(A^\\ast, B^\\ast)$. Consequently, $f$ has the maximum value of any flow in $G$, and $(A^\\ast, B^\\ast)$ has the minimum capacity of any s-t cut in $G$. When Fork-Furkerson Algorithm terminates, let $A^*$ denote the set of all nodes v in G for which there is an s-v path in $G_f$. Let $B^\\ast$ denote the set of all other nodes: $B^\\ast = V − A^\\ast$. ","date":"2021-10-24","objectID":"/zh-cn/posts/algorithm/max-flow/:3:0","tags":["Algorithm"],"title":"最大流","uri":"/zh-cn/posts/algorithm/max-flow/"},{"categories":["CSCI-570 Analysis of Algorithm"],"content":"4. Analysis of Time Complexity definition: $C=\\sum_{e\\ out\\ of\\ s}c_e$ **some conclusion**: Suppose, as above, that all capacities in the flow network $G$ are integers. Then the Ford-Fulkerson Algorithm terminates in at most $C$ iterations of the While loop. All capacities in the flow network $G$ are integers. Then the Ford-Fulkerson Algorithm can be implemented to run in $O(mC)$ time. Scaling Fork-Fulkerson Algorithm When choosing augmenting paths wisely, the Fork-Fulkerson Algorithm can be accelerated. Let $G_f(\\Delta)$ be the subset of the residual graph consisting only of edges with residual capacity of at least $\\Delta$. Scaling Max-Flow Initially f(e) = 0 for all e in G Initially set $\\Delta$ to be the largest power of 2 that is no larger than the maximum capacity out of s: $\\Delta \\leq max_{e\\ out\\ of\\ s} c_e$ While $\\Delta\\geq1$ While there is an s-t path in the graph $G_f(\\Delta)$ Let P be a simple s-t path in $G_f(\\Delta)$ $f^\\prime$ = augment(f , P) Update f to be $f^\\prime$ and update $G_f(\\Delta)$ Endwhile $\\Delta=\\Delta/2$ Endwhile Return f Time Complexity of Fork-Fulkerson Algorithm is $O(m^2log_2C)$ ","date":"2021-10-24","objectID":"/zh-cn/posts/algorithm/max-flow/:4:0","tags":["Algorithm"],"title":"最大流","uri":"/zh-cn/posts/algorithm/max-flow/"},{"categories":["Projects"],"content":"一款背单词的教育游戏 ","date":"2020-02-28","objectID":"/zh-cn/posts/projects/word-pyramid/:0:0","tags":["APP","Game"],"title":"Word Pyramid","uri":"/zh-cn/posts/projects/word-pyramid/"},{"categories":["Projects"],"content":"为什么要做这个游戏 为什么人很容易沉迷游戏，而不会沉迷于工作、学习呢？因为游戏背后有一套完整的心理学理论引导你沉迷其中，包括即时反馈、阶段性目标、虚拟的游戏物品、随机的抽奖…我在想如果将游戏机制与学习结合起来，玩家可以通过在游戏中学习知识获得游戏中的奖励、经验、头衔等等，是不是也可以让人沉迷学习？基于这些想法，并且恰好新冠疫情给了我大把在家的时间，我将这个想法变成了一个手机游戏。 ","date":"2020-02-28","objectID":"/zh-cn/posts/projects/word-pyramid/:1:0","tags":["APP","Game"],"title":"Word Pyramid","uri":"/zh-cn/posts/projects/word-pyramid/"},{"categories":["Projects"],"content":"这是一个怎样的游戏 这是一个经营类的游戏，玩家通过背英语单词赚取金币，金币可以用来建造房子，开阔土地。虽然乍一看这是一个游戏，但是它实际上也是一个完善的背单词APP。作为一个曾经的托福考生，我按照我的经验将托福单词分了类，有些list是学科单词，有些list是容易弄混的词，单词的中文意思我也尽量做到简洁，这样可以让背单词更加高效。除此之外，这个APP还支持单词发音。 这个游戏已经上架了APP Store，下载链接 ","date":"2020-02-28","objectID":"/zh-cn/posts/projects/word-pyramid/:2:0","tags":["APP","Game"],"title":"Word Pyramid","uri":"/zh-cn/posts/projects/word-pyramid/"},{"categories":["Projects"],"content":"如何做这个游戏 我独自完成了游戏的设计、开发、美术。整个游戏是基于Unity引擎开发的，画UI用到了Krita、3D建模用到了MagicaPixel。 ","date":"2020-02-28","objectID":"/zh-cn/posts/projects/word-pyramid/:3:0","tags":["APP","Game"],"title":"Word Pyramid","uri":"/zh-cn/posts/projects/word-pyramid/"},{"categories":["Projects"],"content":"下一步的计划 目前这个游戏取得了200+的下载量和5.0的评分，我下一步的计划： 对设计做一些修改，增加引导环节，让玩家能够更加快的进入游戏角色。 对画面做一些优化，增添夜间和白天的切换。 增加更多的单词库。 ","date":"2020-02-28","objectID":"/zh-cn/posts/projects/word-pyramid/:4:0","tags":["APP","Game"],"title":"Word Pyramid","uri":"/zh-cn/posts/projects/word-pyramid/"},{"categories":["Misc"],"content":"在服务器上面安装配置Nginx ","date":"2019-07-25","objectID":"/zh-cn/posts/misc/how-to-build-nginx-server/:0:0","tags":["Nginx","博客搭建"],"title":"搭建Nginx服务器","uri":"/zh-cn/posts/misc/how-to-build-nginx-server/"},{"categories":["Misc"],"content":"安装Nginx 更新ubuntu软件源 sudo apt-get update 安装nginx sudo apt-get install nginx # 检查是否安装成功 nginx -v 安装好了的文件的位置 /usr/src/nginx :主程序 /etc/nginx :存放配置文件 /usr/share/nginx :存放静态文件 /var/log/nginx :存放日志 ","date":"2019-07-25","objectID":"/zh-cn/posts/misc/how-to-build-nginx-server/:1:0","tags":["Nginx","博客搭建"],"title":"搭建Nginx服务器","uri":"/zh-cn/posts/misc/how-to-build-nginx-server/"},{"categories":["Misc"],"content":"配置Nginx 这部分主要是关于两个Nginx的配置文件的问题 /etc/nginx/nginx.conf 这个文件有默认配置，我们需要做一点修改 # 这个文件有默认的配置 user root; #这个root很重要！ worker_processes auto; pid /run/nginx.pid; events { worker_connections 768; # multi_accept on; } http { ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable \"msie6\"; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## # 需要加上我们的配置文件所在的目录 include /etc/nginx/conf.d/*.conf; #include /etc/nginx/sites-enabled/*; } #mail { # # See sample authentication script at: # # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript # # # auth_http localhost/auth.php; # # pop3_capabilities \"TOP\" \"USER\"; # # imap_capabilities \"IMAP4rev1\" \"UIDPLUS\"; # # server { # listen localhost:110; # protocol pop3; # proxy on; # } # # server { # listen localhost:143; # protocol imap; # proxy on; # } #} /etc/nginx/conf.d/default.conf 在之前的文件include了这个文件，这个文件里的配置是核心配置 server { listen 80; server_name **.**.***.***; location / { root /usr/share/nginx/html/pc; #把请求转到这个目录 index index.html allow all; } location ~/api/ { #把请求转到后端 proxy_pass http://**.**.***.***:8080; } location ~/livecode/ {# 配置websocket proxy_pass http://**.**.***.***:8080; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } } ","date":"2019-07-25","objectID":"/zh-cn/posts/misc/how-to-build-nginx-server/:2:0","tags":["Nginx","博客搭建"],"title":"搭建Nginx服务器","uri":"/zh-cn/posts/misc/how-to-build-nginx-server/"},{"categories":["Misc"],"content":"nginx常见操作 nginx #启动nginx服务 nginx -s stop #强行停止nginx服务 nginx -s quit #完成一些任务后停止nginx服务 nginx -t #检查nginx配置是否正常 nginx -s reload #重启nginx服务 netstat -tnlp #查看端口占用情况 ","date":"2019-07-25","objectID":"/zh-cn/posts/misc/how-to-build-nginx-server/:3:0","tags":["Nginx","博客搭建"],"title":"搭建Nginx服务器","uri":"/zh-cn/posts/misc/how-to-build-nginx-server/"}]